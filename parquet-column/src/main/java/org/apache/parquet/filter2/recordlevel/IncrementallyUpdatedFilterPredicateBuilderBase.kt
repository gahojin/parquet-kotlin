/*
 * Copyright (c) The Apache Software Foundation.
 * Copyright (c) GAHOJIN, Inc.
 *
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.parquet.filter2.recordlevel

import org.apache.parquet.Preconditions.checkArgument
import org.apache.parquet.filter2.predicate.FilterPredicate
import org.apache.parquet.filter2.predicate.Operators
import org.apache.parquet.filter2.recordlevel.IncrementallyUpdatedFilterPredicate.ValueInspector
import org.apache.parquet.hadoop.metadata.ColumnPath
import org.apache.parquet.hadoop.metadata.ColumnPath.Companion.get
import org.apache.parquet.io.PrimitiveColumnIO
import org.apache.parquet.schema.PrimitiveComparator

/**
 * The implementation of this abstract class is auto-generated by
 * org.apache.parquet.filter2.IncrementallyUpdatedFilterPredicateGenerator
 *
 * Constructs a [IncrementallyUpdatedFilterPredicate] from a [FilterPredicate]
 * This is how records are filtered during record assembly. The implementation is generated in order to avoid autoboxing.
 *
 * Note: the supplied predicate must not contain any instances of the not() operator as this is not
 * supported by this filter.
 *
 * the supplied predicate should first be run through [org.apache.parquet.filter2.predicate.LogicalInverseRewriter] to rewrite it
 * in a form that doesn't make use of the not() operator.
 *
 * the supplied predicate should also have already been run through
 * [org.apache.parquet.filter2.predicate.SchemaCompatibilityValidator]
 * to make sure it is compatible with the schema of this file.
 *
 * TODO: UserDefinedPredicates still autobox however
 */
abstract class IncrementallyUpdatedFilterPredicateBuilderBase

    : FilterPredicate.Visitor<IncrementallyUpdatedFilterPredicate> {
    private var built = false
    val valueInspectorsByColumn: MutableMap<ColumnPath, MutableList<ValueInspector>> =
        HashMap<ColumnPath, MutableList<ValueInspector>>()
    private val comparatorsByColumn: MutableMap<ColumnPath, PrimitiveComparator<*>> =
        HashMap<ColumnPath, PrimitiveComparator<*>>()

    @Deprecated("")
    constructor()

    constructor(leaves: List<PrimitiveColumnIO>) {
        for (leaf in leaves) {
            val descriptor = leaf.columnDescriptor
            val path = get(*descriptor.path)
            val comparator: PrimitiveComparator<*> = descriptor.primitiveType.comparator<Any>()
            comparatorsByColumn.put(path, comparator)
        }
    }

    fun build(pred: FilterPredicate): IncrementallyUpdatedFilterPredicate {
        checkArgument(!built, "This builder has already been used")
        val incremental = pred.accept(this)
        built = true
        return incremental
    }

    protected fun addValueInspector(columnPath: ColumnPath, valueInspector: ValueInspector) {
        var valueInspectors = valueInspectorsByColumn.get(columnPath)
        if (valueInspectors == null) {
            valueInspectors = ArrayList<ValueInspector>()
            valueInspectorsByColumn.put(columnPath, valueInspectors)
        }
        valueInspectors.add(valueInspector)
    }

    protected fun <T> getComparator(path: ColumnPath): PrimitiveComparator<T>? {
        return comparatorsByColumn[path] as? PrimitiveComparator<T>
    }

    override fun visit(and: Operators.And): IncrementallyUpdatedFilterPredicate {
        return IncrementallyUpdatedFilterPredicate.And(
            and.left.accept(this),
            and.right.accept(this),
        )
    }

    override fun visit(or: Operators.Or): IncrementallyUpdatedFilterPredicate {
        return IncrementallyUpdatedFilterPredicate.Or(
            or.left.accept(this),
            or.right.accept(this),
        )
    }

    override fun visit(not: Operators.Not): IncrementallyUpdatedFilterPredicate {
        throw IllegalArgumentException("This predicate contains a not! Did you forget to run this predicate through LogicalInverseRewriter? $not")
    }
}
