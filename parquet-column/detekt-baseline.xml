<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
  <ManuallySuppressedIssues/>
  <CurrentIssues>
    <ID>EqualsWithHashCodeExist:Binary.kt$Binary : ComparableSerializable</ID>
    <ID>EqualsWithHashCodeExist:Binary.kt$Binary$ByteArrayBackedBinary : Binary</ID>
    <ID>EqualsWithHashCodeExist:Binary.kt$Binary$ByteArraySliceBackedBinary : Binary</ID>
    <ID>EqualsWithHashCodeExist:Binary.kt$Binary$ByteBufferBackedBinary : Binary</ID>
    <ID>EqualsWithHashCodeExist:BloomFilter.kt$BloomFilter</ID>
    <ID>ForbiddenComment:Binary.kt$Binary.ByteBufferBackedBinary$// TODO: should not have to materialize those bytes</ID>
    <ID>ForbiddenComment:ColumnReaderBase.kt$ColumnReaderBase$// TODO: rework that</ID>
    <ID>ForbiddenComment:ColumnWriterV2.kt$ColumnWriterV2$// TODO: rework this API. The bytes shall be retrieved before the encoding (encoding might be different</ID>
    <ID>ForbiddenComment:DefaultV2ValuesWriterFactory.kt$DefaultV2ValuesWriterFactory$// TODO:</ID>
    <ID>ForbiddenComment:DictionaryPage.kt$DictionaryPage$// TODO: fix sizes long or int</ID>
    <ID>ForbiddenComment:EmptyRecordReader.kt$EmptyRecordReader$// TODO: validator(wrap(recordMaterializer), validating, root.getType());</ID>
    <ID>ForbiddenComment:Encoding.kt$Encoding.RLE$* Actually a combination of bit packing and run length encoding. * TODO: Should we rename this to be more clear?</ID>
    <ID>ForbiddenComment:FilteringGroupConverter.kt$FilteringGroupConverter$// TODO: making the assumption that getConverter(i) is only called once, is that valid?</ID>
    <ID>ForbiddenComment:FilteringPrimitiveConverter.kt$FilteringPrimitiveConverter$// TODO: essentially turns off the benefits of dictionary support</ID>
    <ID>ForbiddenComment:FilteringPrimitiveConverter.kt$FilteringPrimitiveConverter$// TODO: even if the underlying delegate supports it.</ID>
    <ID>ForbiddenComment:FilteringPrimitiveConverter.kt$FilteringPrimitiveConverter$// TODO: this works, but</ID>
    <ID>ForbiddenComment:FilteringPrimitiveConverter.kt$FilteringPrimitiveConverter$// TODO: we should support it here. (https://issues.apache.org/jira/browse/PARQUET-36)</ID>
    <ID>ForbiddenComment:IncrementallyUpdatedFilterPredicateBuilderBase.kt$IncrementallyUpdatedFilterPredicateBuilderBase$* The implementation of this abstract class is auto-generated by * org.apache.parquet.filter2.IncrementallyUpdatedFilterPredicateGenerator * * Constructs a [IncrementallyUpdatedFilterPredicate] from a [FilterPredicate] * This is how records are filtered during record assembly. The implementation is generated in order to avoid autoboxing. * * Note: the supplied predicate must not contain any instances of the not() operator as this is not * supported by this filter. * * the supplied predicate should first be run through [org.apache.parquet.filter2.predicate.LogicalInverseRewriter] to rewrite it * in a form that doesn't make use of the not() operator. * * the supplied predicate should also have already been run through * [org.apache.parquet.filter2.predicate.SchemaCompatibilityValidator] * to make sure it is compatible with the schema of this file. * * TODO: UserDefinedPredicates still autobox however</ID>
    <ID>ForbiddenComment:IncrementallyUpdatedFilterPredicateEvaluator.kt$IncrementallyUpdatedFilterPredicateEvaluator$* Determines whether an [IncrementallyUpdatedFilterPredicate] is satisfied or not. * This implementation makes the assumption that all [ValueInspector]s in an unknown state * represent columns with a null value, and updates them accordingly. * * TODO: We could also build an evaluator that detects if enough values are known to determine the outcome * TODO: of the predicate and quit the record assembly early. (https://issues.apache.org/jira/browse/PARQUET-37)</ID>
    <ID>ForbiddenComment:MessageType.kt$MessageType$// TODO: optimize this</ID>
    <ID>ForbiddenComment:PageReadStore.kt$PageReadStore$* contains all the readers for all the columns of the corresponding row group * * TODO: rename to RowGroup?</ID>
    <ID>ForbiddenComment:RecordConsumer.kt$RecordConsumer$// TODO: make this abstract in 2.0</ID>
    <ID>ForbiddenComment:RunLengthBitPackingHybridDecoder.kt$RunLengthBitPackingHybridDecoder$// TODO: reuse a buffer</ID>
    <ID>ForbiddenComment:RunLengthBitPackingHybridEncoder.kt$RunLengthBitPackingHybridEncoder$* Encodes values using a combination of run length encoding and bit packing, * according to the following grammar: * * ``` * rle-bit-packed-hybrid: &lt;length> &lt;encoded-data> * length := length of the &lt;encoded-data> in bytes stored as 4 bytes little endian * encoded-data := &lt;run>* * run := &lt;bit-packed-run> | &lt;rle-run> * bit-packed-run := &lt;bit-packed-header> &lt;bit-packed-values> * bit-packed-header := varint-encode(&lt;bit-pack-count> &lt;&lt; 1 | 1) * // we always bit-pack a multiple of 8 values at a time, so we only store the number of values / 8 * bit-pack-count := (number of values in this run) / 8 * bit-packed-values := bit packed back to back, from LSB to MSB * rle-run := &lt;rle-header> &lt;repeated-value> * rle-header := varint-encode( (number of times repeated) &lt;&lt; 1) * repeated-value := value that is repeated, using a fixed-width of round-up-to-next-byte(bit-width) * ``` * * NOTE: this class is only responsible for creating and returning the `&lt;encoded-data>` * portion of the above grammar. The `&lt;length>` portion is done by * [RunLengthBitPackingHybridValuesWriter] * * Only supports positive values (including 0) // TODO: is that ok? Should we make a signed version? * * </ID>
    <ID>ForbiddenComment:UserDefinedPredicate.kt$UserDefinedPredicate$// TODO: consider avoiding autoboxing and adding the specialized methods for each type</ID>
    <ID>ForbiddenComment:UserDefinedPredicate.kt$UserDefinedPredicate$// TODO: downside is that's fairly unwieldy for users</ID>
    <ID>ForbiddenComment:ValidTypeMap.kt$ValidTypeMap$* Contains all valid mappings from class -&amp;gt; parquet type (and vice versa) for use in * [FilterPredicate]s * * This is a bit ugly, but it allows us to provide good error messages at runtime * when there are type mismatches. * * TODO: this has some overlap with [PrimitiveTypeName.javaType] * TODO: (https://issues.apache.org/jira/browse/PARQUET-30)</ID>
    <ID>ForbiddenComment:ValuesWriter.kt$ValuesWriter$// TODO: maybe consolidate into a getPage</ID>
    <ID>FunctionParameterNaming:Binary.kt$Binary.ByteBufferBackedBinary$`in`: ObjectInputStream</ID>
    <ID>FunctionParameterNaming:ColumnReaderBase.kt$ColumnReaderBase$`in`: ByteBufferInputStream</ID>
    <ID>FunctionParameterNaming:FilterPredicate.kt$FilterPredicate.Visitor$`in`: In&lt;T></ID>
    <ID>FunctionParameterNaming:ValuesReader.kt$ValuesReader$`in`: ByteBufferInputStream</ID>
    <ID>InstanceOfCheckForException:ColumnReaderBase.kt$ColumnReaderBase$e is ArrayIndexOutOfBoundsException</ID>
    <ID>LongMethod:MessageTypeParser.kt$MessageTypeParser$private fun addPrimitiveType(st: Tokenizer, type: PrimitiveTypeName, r: Repetition, builder: GroupBuilder&lt;*>)</ID>
    <ID>MaxLineLength:Binary.kt$Binary.ByteArrayBackedBinary$@Deprecated("will be removed in 2.0.0. The comparison logic depends on the related logical type therefore this one\n might not be correct. The {@link java.util.Comparator} implementation for the related type available at\n {@link org.apache.parquet.schema.PrimitiveType#comparator} should be used instead.")</ID>
    <ID>MaxLineLength:Binary.kt$Binary.ByteArraySliceBackedBinary$@Deprecated("will be removed in 2.0.0. The comparison logic depends on the related logical type therefore this one\n might not be correct. The {@link java.util.Comparator} implementation for the related type available at\n {@link org.apache.parquet.schema.PrimitiveType#comparator} should be used instead.")</ID>
    <ID>MaxLineLength:Binary.kt$Binary.ByteBufferBackedBinary$@Deprecated("will be removed in 2.0.0. The comparison logic depends on the related logical type therefore this one\n might not be correct. The {@link java.util.Comparator} implementation for the related type available at\n {@link org.apache.parquet.schema.PrimitiveType#comparator} should be used instead.")</ID>
    <ID>MaxLineLength:ColumnReaderBase.kt$ColumnReaderBase$"Can't read value in column %s at value %d out of %d, %d out of %d in currentPage. repetition level: %d, definition level: %d"</ID>
    <ID>MaxLineLength:DataPageV2.kt$DataPageV2$return "Page V2 [dl size=${definitionLevels.size()}, rl size=${repetitionLevels.size()}, data size=${data.size()}, data enc=${dataEncoding}, valueCount=${valueCount}, rowCount=${rowCount}, is compressed=${isCompressed}, uncompressedSize=${uncompressedSize}]"</ID>
    <ID>MaxLineLength:ParquetProperties.kt$ParquetProperties$PrimitiveTypeName.INT32, PrimitiveTypeName.INT64, PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY -> byteStreamSplitEnabled.getValue(column) == ByteStreamSplitMode.EXTENDED</ID>
    <ID>MaxLineLength:Statistics.kt$Statistics$*</ID>
    <ID>NestedBlockDepth:Float16.kt$Float16$@JvmStatic fun toFloat16(f: kotlin.Float): Short</ID>
    <ID>NestedBlockDepth:GroupWriter.kt$GroupWriter$private fun writeGroup(group: Group, type: GroupType)</ID>
    <ID>NestedBlockDepth:MessageColumnIO.kt$MessageColumnIO.MessageColumnIORecordConsumer$fun writeNullForMissingFieldsAtCurrentLevel()</ID>
    <ID>NestedBlockDepth:MessageTypeParser.kt$MessageTypeParser$private fun addPrimitiveType(st: Tokenizer, type: PrimitiveTypeName, r: Repetition, builder: GroupBuilder&lt;*>)</ID>
    <ID>NestedBlockDepth:OffsetIndexBuilder.kt$OffsetIndexBuilder.OffsetIndexImpl$override fun toString(): String</ID>
    <ID>NestedBlockDepth:SimpleGroup.kt$SimpleGroup$private fun appendToString(builder: StringBuilder, indent: String): StringBuilder</ID>
    <ID>ReturnCount:CorruptDeltaByteArrays.kt$CorruptDeltaByteArrays$@JvmStatic fun requiresSequentialReads(createdBy: String?, encoding: Encoding?): Boolean</ID>
    <ID>ReturnCount:CorruptDeltaByteArrays.kt$CorruptDeltaByteArrays$@JvmStatic fun requiresSequentialReads(semver: SemanticVersion?, encoding: Encoding?): Boolean</ID>
    <ID>ReturnCount:CorruptDeltaByteArrays.kt$CorruptDeltaByteArrays$@JvmStatic fun requiresSequentialReads(version: ParsedVersion?, encoding: Encoding?): Boolean</ID>
    <ID>ReturnCount:CorruptStatistics.kt$CorruptStatistics$@JvmStatic fun shouldIgnoreStatistics(createdBy: String?, columnType: PrimitiveTypeName): Boolean</ID>
    <ID>ReturnCount:EncodingStats.kt$EncodingStats$fun hasNonDictionaryEncodedPages(): Boolean</ID>
    <ID>ReturnCount:Float16.kt$Float16$@JvmStatic fun compare(x: Short, y: Short): Int</ID>
    <ID>ReturnCount:Type.kt$Type.Repetition.Companion$@JvmStatic fun leastRestrictive(vararg repetitions: Repetition?): Repetition</ID>
    <ID>SpreadOperator:ByteStreamSplitValuesWriter.kt$ByteStreamSplitValuesWriter$(*allInputs)</ID>
    <ID>SpreadOperator:ColumnProperty.kt$ColumnProperty$(*columnDescriptor.path)</ID>
    <ID>SpreadOperator:ColumnProperty.kt$ColumnProperty.Builder$(*columnDescriptor.path)</ID>
    <ID>SpreadOperator:FilteringGroupConverter.kt$FilteringGroupConverter$(*columnIO.columnDescriptor.path)</ID>
    <ID>SpreadOperator:IncrementallyUpdatedFilterPredicateBuilderBase.kt$IncrementallyUpdatedFilterPredicateBuilderBase$(*descriptor.path)</ID>
    <ID>SpreadOperator:MessageType.kt$MessageType$(*it)</ID>
    <ID>SpreadOperator:MessageType.kt$MessageType$(*path)</ID>
    <ID>ThrowsCount:ColumnWriterBase.kt$ColumnWriterBase$fun writePage()</ID>
    <ID>ThrowsCount:ValidatingRecordConsumer.kt$ValidatingRecordConsumer$private fun validate(vararg ptypes: PrimitiveTypeName)</ID>
    <ID>TooGenericExceptionCaught:BinaryPlainValuesReader.kt$BinaryPlainValuesReader$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:ColumnReaderBase.kt$ColumnReaderBase$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:ColumnWriterBase.kt$ColumnWriterBase$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:ColumnWriterBase.kt$ColumnWriterBase$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:CorruptDeltaByteArrays.kt$CorruptDeltaByteArrays$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:CorruptStatistics.kt$CorruptStatistics$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:FixedLenByteArrayPlainValuesReader.kt$FixedLenByteArrayPlainValuesReader$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:GroupColumnIO.kt$GroupColumnIO$e: IndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:MessageColumnIO.kt$MessageColumnIO.MessageColumnIORecordConsumer$e: RuntimeException</ID>
    <ID>TooGenericExceptionThrown:ConversionPatterns.kt$ConversionPatterns$throw RuntimeException("${it.name} should be value")</ID>
    <ID>TooGenericExceptionThrown:SimpleGroup.kt$SimpleGroup$throw RuntimeException( "not found $fieldIndex(${schema.getFieldName(fieldIndex)}) element number $index in group:\n$this")</ID>
    <ID>TooGenericExceptionThrown:SimpleGroup.kt$SimpleGroup$throw RuntimeException( "not found $fieldIndex(${schema.getFieldName(fieldIndex)}) in group:\n$this")</ID>
    <ID>UnusedPrivateMember:Binary.kt$Binary.ByteBufferBackedBinary$@Throws(IOException::class) private fun writeObject(out: ObjectOutputStream)</ID>
    <ID>UnusedPrivateMember:Binary.kt$Binary.ByteBufferBackedBinary$@Throws(IOException::class, ClassNotFoundException::class) private fun readObject(`in`: ObjectInputStream)</ID>
    <ID>UnusedPrivateMember:Binary.kt$Binary.ByteBufferBackedBinary$@Throws(ObjectStreamException::class) private fun readObjectNoData()</ID>
    <ID>UnusedPrivateProperty:ValuesReader.kt$ValuesReader$i</ID>
    <ID>VariableNaming:BinaryPlainValuesReader.kt$BinaryPlainValuesReader$private lateinit var `in`: ByteBufferInputStream</ID>
    <ID>VariableNaming:BitPackingValuesReader.kt$BitPackingValuesReader$private lateinit var `in`: ByteBufferInputStream</ID>
    <ID>VariableNaming:BooleanPlainValuesReader.kt$BooleanPlainValuesReader$private val `in` = ByteBitPackingValuesReader(1, Packer.LITTLE_ENDIAN)</ID>
    <ID>VariableNaming:ByteBitPackingValuesReader.kt$ByteBitPackingValuesReader$private lateinit var `in`: ByteBufferInputStream</ID>
    <ID>VariableNaming:ColumnReaderBase.kt$ColumnReaderBase$val `in` = bytes.toInputStream()</ID>
    <ID>VariableNaming:FixedLenByteArrayPlainValuesReader.kt$FixedLenByteArrayPlainValuesReader$private lateinit var `in`: ByteBufferInputStream</ID>
    <ID>VariableNaming:PlainValuesReader.kt$PlainValuesReader$protected lateinit var `in`: LittleEndianDataInputStream</ID>
    <ID>WrongEqualsTypeParameter:Binary.kt$Binary$abstract fun equals(other: Binary): Boolean</ID>
    <ID>WrongEqualsTypeParameter:Binary.kt$Binary.ByteArrayBackedBinary$override fun equals(other: Binary): Boolean</ID>
    <ID>WrongEqualsTypeParameter:Binary.kt$Binary.ByteArraySliceBackedBinary$override fun equals(other: Binary): Boolean</ID>
    <ID>WrongEqualsTypeParameter:Binary.kt$Binary.ByteBufferBackedBinary$override fun equals(other: Binary): Boolean</ID>
    <ID>WrongEqualsTypeParameter:Type.kt$Type$protected open fun equals(other: Type): Boolean</ID>
  </CurrentIssues>
</SmellBaseline>
