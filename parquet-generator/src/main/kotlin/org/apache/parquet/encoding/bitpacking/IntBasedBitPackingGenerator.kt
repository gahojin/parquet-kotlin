/*
 * Copyright (c) The Apache Software Foundation.
 * Copyright (c) GAHOJIN, Inc.
 *
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.parquet.encoding.bitpacking

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import java.nio.file.Path
import kotlin.io.path.Path
import kotlin.math.abs

object IntBasedBitPackingGenerator {
  private const val PACKAGE_NAME = "org.apache.parquet.column.values.bitpacking"
  private const val CLASS_NAME_PREFIX: String = "LemireBitPacking"

  fun main(args: Array<String>) {
    val basePath = Path(args[0])

    generateScheme("${CLASS_NAME_PREFIX}BE", true, basePath)
    generateScheme("${CLASS_NAME_PREFIX}LE", false, basePath)
  }

  private fun generateScheme(className: String, msbFirst: Boolean, basePath: Path) {
    val packerClass = ClassName(PACKAGE_NAME, "IntPacker")
    val factoryClass = ClassName(PACKAGE_NAME, "IntPackerFactory")

    val schemaClass = TypeSpec.classBuilder(className)
      .addModifiers(KModifier.PUBLIC, KModifier.ABSTRACT)
      .addType(TypeSpec.companionObjectBuilder()
        .addProperty(PropertySpec.builder("packers", ARRAY.parameterizedBy(packerClass))
          .addModifiers(KModifier.PRIVATE)
          // private val packers: Array<IntPacker> = arrayOf(...)
          .initializer(CodeBlock.builder()
            .add("arrayOf(\n").apply {
              indent()
              for (i in 0..31) {
                addStatement("Packer${i},")
              }
              unindent()
            }
            .add(")")
            .build()
          )
          .build())
        .addProperty(PropertySpec.builder("factory", factoryClass)
          .addModifiers(KModifier.PUBLIC)
          .addAnnotation(JvmField::class)
          // val factory: BytePackersXXXFactory = object : IntPackerFactory { }
          .initializer("%L", TypeSpec.anonymousClassBuilder()
            .addSuperinterface(factoryClass)
            .addFunction(FunSpec.builder("newIntPacker")
              .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
              .addParameter("width", Int::class)
              .returns(packerClass)
              .addStatement("return packers[width]")
              .build()
            )
            .build()
          )
          .build()
        )
        .build()
      )
      .addTypes((0..31).map { width ->
        TypeSpec.objectBuilder(ClassName(PACKAGE_NAME, "Packer${width}"))
          .superclass(packerClass)
          .addModifiers(KModifier.PRIVATE)
          .addSuperclassConstructorParameter("%L", width).apply {
            generatePack(width, msbFirst)
            generateUnpack(width, msbFirst)
          }
          .build()
      })
      .build()

    val schemaFile = FileSpec.builder(PACKAGE_NAME, className)
      .addFileComment("This class is auto-generated by ${PACKAGE_NAME}.${className}\nDo not manually edit!")
      .addImport("java.nio", "ByteBuffer")
      .addType(schemaClass)
      .build()

    schemaFile.writeTo(basePath)
  }


  private fun TypeSpec.Builder.generatePack(
    width: Int,
    msbFirst: Boolean,
  ) {
    val mask = genMask(width)

    addFunction(FunSpec.builder("pack32Values")
      .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
      .addParameter("input", INT_ARRAY)
      .addParameter("inputPos", INT)
      .addParameter("output", INT_ARRAY)
      .addParameter("outputPos", INT)
      .apply {
        for (index in 0..<width) {
          addStatement(buildString {
            append("output[$index + outputPos] = ")

            val startIndex = index * 32 / width
            val endIndex = ((index + 1) * 32 + width - 1) / width
            for (valueIndex in startIndex..<endIndex) {
              val shiftString = getPackShiftString(width, msbFirst, index, startIndex, valueIndex)
              val joinString = if (valueIndex < endIndex - 1) " or " else ""

              append("(input[$valueIndex + inputPos] and $mask$shiftString)$joinString")
            }
          })
        }
      }
      .build())
  }

  private fun TypeSpec.Builder.generateUnpack(
    width: Int,
    msbFirst: Boolean,
  ) {
    val mask = genMask(width)

    addFunction(FunSpec.builder("unpack32Values")
      .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
      .addParameter("input", INT_ARRAY)
      .addParameter("inputPos", INT)
      .addParameter("output", INT_ARRAY)
      .addParameter("outputPos", INT)
      .apply {
        if (width <= 0) {
          return@apply
        }
        for (index in 0..<32) {
          addStatement(buildString {
            val byteIndex = index * width / 32
            val shiftString = getUnpackShiftString(width, msbFirst, index)
            val existsNextStatement = ((index + 1) * width - 1) / 32 != byteIndex
            val joinStatement = if (existsNextStatement) " or " else ""
            append("output[$index + outputPos] = (input[$byteIndex + inputPos]$shiftString and $mask)$joinStatement")

            if (existsNextStatement) {
              // reading the end of the value from next int
              val bitsRead = ((index + 1) * width - 1) % 32 + 1
              val shiftStringStr = if (msbFirst) {
                " ushr ${32 - bitsRead}"
              } else {
                val lowerMask = (1 shl bitsRead) - 1
                " and $lowerMask shl ${width - bitsRead}"
              }
              append("(input[${byteIndex + 1} + inputPos]$shiftStringStr)")
            }
          })
        }
      }
      .build())
  }

  private fun getPackShiftString(
    width: Int,
    msbFirst: Boolean,
    index: Int,
    startIndex: Int,
    valueIndex: Int,
  ): String {
    val regularShift = (valueIndex * width) % 32
    return if (msbFirst) {
      // filling most significant bit first
      val shift = 32 - (regularShift + width)
      if (valueIndex == startIndex && (index * 32) % width != 0) {
        // end of last value from previous int
        " shl ${32 - (((valueIndex + 1) * width) % 32)}"
      } else if (shift < 0) {
        " ushr ${abs(shift)}"
      } else {
        " shl $shift"
      }
    } else {
      // filling the least significant bit first
      if (valueIndex == startIndex && (index * 32) % width != 0) {
        // end of last value from previous int
        " ushr ${32 - regularShift}"
      } else {
        " shl $regularShift"
      }
    }
  }

  private fun getUnpackShiftString(
    width: Int,
    msbFirst: Boolean,
    index: Int,
  ): String {
    val regularShift = (index * width) % 32
    return if (msbFirst) {
      val shift = 32 - (regularShift + width)
      if (shift < 0) {
        " shl ${abs(shift)}"
      } else {
        " ushr $shift"
      }
    } else {
      " ushr $regularShift"
    }
  }
}
